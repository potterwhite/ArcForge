// Copyright (c) 2025 PotterWhite
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include "asr-task-sherpa.h"
#include "Utils/logger/logger.h"
#include "common-types.h"

// --- 配置 ---
// Sherpa-ONNX 模型路径 (根据你的实际路径修改)
// 你使用的是rknn模型，需要确保provider正确设置为"rknn"
// 我这里先用通用zipformer示例路径，请务必替换成你RK3588的rknn模型路径！
const std::string ENCODER_PATH =
    "/home/asr/models/sherpa-onnx-rk3588-streaming-zipformer-bilingual-zh-en-2023-02-20/"
    "encoder.rknn";
const std::string DECODER_PATH =
    "/home/asr/models/sherpa-onnx-rk3588-streaming-zipformer-bilingual-zh-en-2023-02-20/"
    "decoder.rknn";
const std::string JOINER_PATH =
    "/home/asr/models/sherpa-onnx-rk3588-streaming-zipformer-bilingual-zh-en-2023-02-20/"
    "joiner.rknn";
const std::string TOKENS_PATH =
    "/home/asr/models/sherpa-onnx-rk3588-streaming-zipformer-bilingual-zh-en-2023-02-20/"
    "tokens.txt";

const std::string PROVIDER = "rknn";  // **** 修改为 "rknn" 如果你在RK3588上运行 ****
// --num-threads=1 to select RKNN_NPU_CORE_AUTO
// --num-threads=0 to select RKNN_NPU_CORE_0
// --num-threads=-1 to select RKNN_NPU_CORE_1
// --num-threads=-2 to select RKNN_NPU_CORE_2
// --num-threads=-3 to select RKNN_NPU_CORE_0_1
// --num-threads=-4 to select RKNN_NPU_CORE_0_1_2
const int NUM_THREADS = -4;

std::unique_ptr<ASRTaskSherpa> ASRTaskSherpa::Create(
    std::unique_ptr<arcforge::embedded::network_socket::Base> client) {

	// return std::make_unique<ASRTaskSherpa>();
	auto task = std::unique_ptr<ASRTaskSherpa>(new ASRTaskSherpa());
	task->setClient(std::move(client));

	return task;
}

ASRTaskSherpa::ASRTaskSherpa() {
	arcforge::embedded::utils::Logger::GetInstance().Info("constructor of ASRTaskSherpa class",
	                                                      kcurrent_app_name);
	init();
}

ASRTaskSherpa::~ASRTaskSherpa() {
	arcforge::embedded::utils::Logger::GetInstance().Info("deconstructor of ASRTaskSherpa class",
	                                                      kcurrent_app_name);
}

void ASRTaskSherpa::setClient(std::unique_ptr<arcforge::embedded::network_socket::Base> client) {
	client_ = std::move(client);
}

bool ASRTaskSherpa::isCompleted() const {
	return finished_flag_;
}

bool ASRTaskSherpa::init() {
	// --- 1. 初始化 ASR 引擎 ---
	arcforge::embedded::ai_asr::SherpaConfig config =
	    arcforge::embedded::ai_asr::SherpaConfig::Builder()
	        .setFirstEncoderPath(ENCODER_PATH)
	        .setSecondDecoderPath(DECODER_PATH)
	        .setThirdJoinerPath(JOINER_PATH)
	        .setFourthTokensPath(TOKENS_PATH)
	        .setFifthProvider(PROVIDER)
	        .setSixthNumThreads(NUM_THREADS)
	        .setTwelfthEndpointDetectionSupport(
	            arcforge::embedded::ai_asr::SherpaEndPointSupport::kenable)
	        .build();

	bool Erfolg = asr_engine_.Initialize(config);
	if (!Erfolg) {
		arcforge::embedded::utils::Logger::GetInstance().Error(
		    "Failed to initialize ASR engine. Exiting.", kcurrent_app_name);
		return false;
	}

	arcforge::embedded::utils::Logger::GetInstance().Info("ASRTaskSherpa has done with init!",
	                                                      kcurrent_app_name);

	return true;
}

void ASRTaskSherpa::run() {
	arcforge::embedded::utils::Logger::GetInstance().Info(
	    "Worker thread started for a new client.");

	// 主循环，由原子标志位 stop_flag_ 控制
	while (stop_flag_ == false) {

		std::vector<float> audio_chunk;
		arcforge::embedded::network_socket::SocketReturnValue retval;

		// --- 步骤 1: 安全地接收数据 ---
		// 在访问 client_ 之前，必须加锁。
		// 这个锁会保护整个 receiveFloat 调用，确保在接收期间，主线程不会 reset client_。
		{
			std::lock_guard<std::mutex> lock(client_mutex_);

			// 再次检查 client_，因为它可能在两次循环之间被 stop_me() 销毁
			if (!client_) {
				// 如果 client_ 没了，说明被要求停止，直接退出循环
				break;
			}

			// 在锁的保护下调用阻塞的 IO 方法
			retval = client_->receiveFloat(audio_chunk);
		}  // 锁在此处自动释放

		// --- 步骤 2: 处理接收结果 ---
		// 如果接收不成功（包括被 stop_me 中断），则退出循环
		if (retval != arcforge::embedded::network_socket::SocketReturnValue::ksuccess) {
			std::string reason;
			switch (retval) {
				case arcforge::embedded::network_socket::SocketReturnValue::ksuccess:
					reason = "Successful receive.";
					break;
				case arcforge::embedded::network_socket::SocketReturnValue::keof:
					reason = "Client closed connection gracefully (EOF).";
					break;
				case arcforge::embedded::network_socket::SocketReturnValue::kpeer_abnormally_closed:
					reason = "Peer abnormally closed connection.";
					break;
				case arcforge::embedded::network_socket::SocketReturnValue::kreceived_illegal:
					reason =
					    "recv() failed, likely because server initiated shutdown by closing the "
					    "socket.";
					break;
				case arcforge::embedded::network_socket::SocketReturnValue::kreceived_null:
				case arcforge::embedded::network_socket::SocketReturnValue::kreceivelength_failed:
				case arcforge::embedded::network_socket::SocketReturnValue::ksendcount_failed:
				case arcforge::embedded::network_socket::SocketReturnValue::ksenddata_failed:
				case arcforge::embedded::network_socket::SocketReturnValue::ksendlength_failed:
				case arcforge::embedded::network_socket::SocketReturnValue::kcount_too_large:
				case arcforge::embedded::network_socket::SocketReturnValue::kempty_string:
				case arcforge::embedded::network_socket::SocketReturnValue::kfd_illegal:
				case arcforge::embedded::network_socket::SocketReturnValue::ksocketpath_empty:
				case arcforge::embedded::network_socket::SocketReturnValue::kconnect_server_failed:
				case arcforge::embedded::network_socket::SocketReturnValue::klisten_error:
				case arcforge::embedded::network_socket::SocketReturnValue::kbind_error:
				case arcforge::embedded::network_socket::SocketReturnValue::kaccept_timeout:
				case arcforge::embedded::network_socket::SocketReturnValue::ksetsocketopt_error:
				case arcforge::embedded::network_socket::SocketReturnValue::kimpl_nullptr_error:
				case arcforge::embedded::network_socket::SocketReturnValue::kinit_state:
				case arcforge::embedded::network_socket::SocketReturnValue::kunknownerror:
				default:
					reason = "An unexpected socket error occurred: " +
					         arcforge::embedded::network_socket::SocketReturnValueToString(retval);
					break;
			}
			arcforge::embedded::utils::Logger::GetInstance().Info(
			    "Exiting worker thread. Reason: " + reason);
			break;  // 退出 while 循环
		}

		// --- 步骤 3: ASR 处理 (这部分是纯计算，不需要锁) ---
		asr_engine_.ProcessAudioChunk(audio_chunk);
		std::string recognized_text = asr_engine_.GetCurrentText();

		// --- 步骤 4: 安全地发送结果 ---
		// 同样，在访问 client_ 之前加锁
		{
			std::lock_guard<std::mutex> lock(client_mutex_);

			if (!client_) {
				arcforge::embedded::utils::Logger::GetInstance().Warning(
				    "Client connection was closed before sending result.");
				break;  // 退出 while 循环
			}

			retval = client_->sendString(recognized_text);
		}  // 锁在此处自动释放

		// 如果发送失败，也退出循环
		if (retval != arcforge::embedded::network_socket::SocketReturnValue::ksuccess) {
			arcforge::embedded::utils::Logger::GetInstance().Error(
			    "Failed to send string data, exiting worker thread.");
			break;
		}

		// --- 步骤 5: 重置 ASR 流 (不需要锁) ---
		asr_engine_.ResetStream();
	}

	// --- 循环结束后的统一清理工作 ---
	finished_flag_ = true;
	arcforge::embedded::utils::Logger::GetInstance().Info(
	    "ASRTaskSherpa run loop finished, worker thread is now exiting.");
}
// void ASRTaskSherpa::run() {
// 	while (1) {
// 		if (stop_flag_ == true) {
// 			arcforge::embedded::utils::Logger::GetInstance().Debug(
// 			    "ASRTaskSherpa class run() return right now", kcurrent_app_name);
// 			break;

// 		} else {
// 			// std::stringstream ss;
// 			// ss << std::this_thread::get_id() << ": "
// 			//    << "wow, ASRTaskSherpa::run() 20000 again!";
// 			// arcforge::embedded::utils::Logger::GetInstance().Debug(ss.str());
// 			// i = 0;

// 			// std::this_thread::sleep_for(std::chrono::milliseconds(1000));
// 			//--------------------------------------------------------------
// 			// --- 3. 循环处理 ---
// 			if (client_ == nullptr) {
// 				arcforge::embedded::utils::Logger::GetInstance().Error(
// 				    "ASRTaskSherpa`s client_ is nullptr");

// 				continue;
// 			}

// 			//----------------------------------
// 			// means we have data now
// 			std::vector<float> audio_chunk;
// 			arcforge::embedded::network_socket::SocketReturnValue retval =
// 			    client_->receiveFloat(audio_chunk);
// 			if (retval > arcforge::embedded::network_socket::SocketReturnValue::ksuccess) {
// 				arcforge::embedded::utils::Logger::GetInstance().Debug(
// 				    arcforge::embedded::network_socket::SocketReturnValueToString(retval));

// 				if (retval ==
// 				    arcforge::embedded::network_socket::SocketReturnValue::kpeer_abnormally_closed) {
// 					std::stringstream ss;
// 					ss << std::this_thread::get_id() << ": "
// 					   << "Peer abnormally closed, terminate myself.";
// 					arcforge::embedded::utils::Logger::GetInstance().Warning(ss.str());

// 					// return;
// 					break;
// 				}

// 				arcforge::embedded::utils::Logger::GetInstance().Error(
// 				    "SocketServer (via client_connection) failed to receive "
// 				    "float data.\n drop this packet ",
// 				    kcurrent_app_name);
// 				continue;
// 			}

// 			// judge if meet eof(end of file)
// 			if (retval == arcforge::embedded::network_socket::SocketReturnValue::keof) {
// 				arcforge::embedded::utils::Logger::GetInstance().Debug("Received EOF from client",
// 				                                                     kcurrent_app_name);
// 				break;
// 			}

// 			asr_engine_.ProcessAudioChunk(audio_chunk);

// 			std::string recognized_text = asr_engine_.GetCurrentText();
// 			std::ostringstream oss;
// 			oss << "Segmentsss " << recognized_text;
// 			arcforge::embedded::utils::Logger::GetInstance().Debug(oss.str(), kcurrent_app_name);
// 			retval = client_->sendString(recognized_text);
// 			if (retval > arcforge::embedded::network_socket::SocketReturnValue::ksuccess) {

// 				arcforge::embedded::utils::Logger::GetInstance().Error(
// 				    "SocketServer (via client_connection) failed to send std::string data.\n "
// 				    "just goto next",
// 				    kcurrent_app_name);
// 				continue;
// 			}

// 			// reset stream
// 			asr_engine_.ResetStream();

// 			arcforge::embedded::utils::Logger::GetInstance().Debug(
// 			    "+++++last statement of this round of loop\n", kcurrent_app_name);
// 		}
// 	}

// 	// 循环结束后的清理工作
// 	finished_flag_ = true;  // <--- 循环正常结束后也要设置标志
// 	arcforge::embedded::utils::Logger::GetInstance().Info(
// 	    "ASRTaskSherpa run loop finished(finished flag has been set to true).");
// }

// stop_me() 的最终线程安全版本
void ASRTaskSherpa::stop_me() {
	stop_flag_ = true;
	std::lock_guard<std::mutex> lock(client_mutex_);
	if (client_) {
		client_.reset();
	}
}
// void ASRTaskSherpa::stop_me() {
// 	stop_flag_ = true;
// 	arcforge::embedded::utils::Logger::GetInstance().Info(
// 	    "ASRTaskSherpa has set stop flag, infinite loop will be notified at its next run.");
// }
